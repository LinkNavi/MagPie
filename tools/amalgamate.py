#!/usr/bin/env python3
"""
amalgamate.py — combines multiple header files into a single amalgamated header.

Usage:
    python amalgamate.py src/token.h src/lexer.h -o build/scriptlang.h --guard SCRIPTLANG_H

How it works:
    - Reads each input file in order.
    - Strips any #include directives that reference OTHER files in the input list
      (i.e. internal includes). External includes like <string> or <vector> are kept.
    - Wraps everything in the provided include guard.
    - Writes the result to the output path.
"""

import argparse
import os
import sys


def is_internal_include(line: str, internal_basenames: set) -> bool:
    """Check if a #include line references one of our own headers."""
    stripped = line.strip()
    if not stripped.startswith('#include'):
        return False
    # Match both "file.h" and <file.h> styles
    for name in internal_basenames:
        if f'"{name}"' in stripped or f'<{name}>' in stripped:
            return True
    return False


def main():
    parser = argparse.ArgumentParser(description='Amalgamate C++ headers into a single file.')
    parser.add_argument('inputs', nargs='+', help='Input header files, in order.')
    parser.add_argument('-o', '--output', required=True, help='Output amalgamated header path.')
    parser.add_argument('--guard', required=True, help='Include guard macro name.')
    args = parser.parse_args()

    # Build a set of the basenames of our internal headers so we can strip their includes
    internal_basenames = {os.path.basename(f) for f in args.inputs}

    output_lines = []
    output_lines.append(f'// ------------------------------------------------------------')
    output_lines.append(f'// {os.path.basename(args.output)}')
    output_lines.append(f'// Auto-generated by amalgamate.py — do not edit manually.')
    output_lines.append(f'// ------------------------------------------------------------')
    output_lines.append(f'')
    output_lines.append(f'#ifndef {args.guard}')
    output_lines.append(f'#define {args.guard}')
    output_lines.append(f'')

    for filepath in args.inputs:
        if not os.path.exists(filepath):
            print(f'ERROR: input file not found: {filepath}', file=sys.stderr)
            sys.exit(1)

        output_lines.append(f'// ==============================================================')
        output_lines.append(f'// BEGIN: {filepath}')
        output_lines.append(f'// ==============================================================')
        output_lines.append(f'')

        with open(filepath, 'r') as f:
            for line in f:
                # Strip internal includes, keep everything else
                if is_internal_include(line, internal_basenames):
                    continue
                # Strip per-file include guards if present (we use one global guard)
                stripped = line.strip()
                if stripped.startswith('#ifndef') or stripped.startswith('#define') or stripped.startswith('#endif'):
                    # Simple heuristic: skip if it looks like a per-file guard
                    # (contains the filename in uppercase)
                    guard_candidate = os.path.basename(filepath).upper().replace('.', '_').replace('-', '_')
                    if guard_candidate in stripped:
                        continue
                output_lines.append(line.rstrip())

        output_lines.append(f'')
        output_lines.append(f'// ==============================================================')
        output_lines.append(f'// END: {filepath}')
        output_lines.append(f'// ==============================================================')
        output_lines.append(f'')

    output_lines.append(f'#endif // {args.guard}')
    output_lines.append(f'')

    os.makedirs(os.path.dirname(args.output) if os.path.dirname(args.output) else '.', exist_ok=True)
    with open(args.output, 'w') as f:
        f.write('\n'.join(output_lines))

    print(f'Amalgamated {len(args.inputs)} headers -> {args.output}')


if __name__ == '__main__':
    main()
